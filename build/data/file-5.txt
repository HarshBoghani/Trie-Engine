greedy good john smith trouble topcoder member learned master force dynamic programming began solving problem problem obedient computer acts quite unfriendly today following usual morning ritual john woke 10 cup coffee went solve problem breakfast something didn t seem right beginning based vast newly acquired experience wrote algorithm flash tired allocating matrices morning morning computer complained segmentation fault despite empty stomach john brilliant idea gets rid beloved matrix adding extra cycle computer cries time limit exceeded instead going nuts john makes radical decision enough programming says decides take vacation reward hard work energetic guy john wants time life many things unfortunately impossible enjoy soon eats breakfast devises fun plan describes schedule upcoming activities now wishes take advantage many careful planning requires cleverness mind gone vacation john smith s problem needs help help nice holiday maybe let s make assumption first john meticulous programmer agrees something sticks plan individual activities either chosen two choices regarding first activity make another two choices regarding second short analysis find 2 n possible choices case 1024 check one individually see whether abides time restrictions finding choice activities selected trivial quite lot alternatives john need enlist help tired computer happens 50 activities even powerful computer world handling situation literally take years approach clearly feasible let s simply problem trust basic instinct moment good approach take chance first opportunity arises two activities follow clash choose one starts earlier order save time case john start first evening debugging room early next morning plane catch less day already started second activity great actually best choice now happens next spending 5 days hawaii time consuming saturday evening still two activities performed think activities done five day span although fast simple approach unfortunately accurate still don t want check every possible solution let s try another trick committing time intensive activity like exotic trip hawaii simply avoided selecting first activity takes least amount time continuing process remaining activities compatible already selected according previous schedule first choose shower 15 minutes consumed best local choice like know whether still keep local best compatible activities selected john s schedule look like take shower 15 minutes participate topcoder single round match 2 hours participate eat drink challenge 2 hours 58 minutes debug room 3 hours attend rock concert 4 hours paintball fun 6 hours 10 possible activities able select 6 bad now run slow trustworthy algorithm see actually best choice make answer indeed 6 john appreciative help returns holiday confident ingenious approach face serious problem going short date misses school exam match favorite team topcoders get used writing reliable programs single case handle dooms approach failure generally situations like analyze caused error first place act accordingly avoid future let s look previous scenario dating activity clashes exam match two clash date idea almost comes always select activity produces minimum amount clashes remaining activities seems logical makes sense now ll try prove approach indeed correct suppose already selected activity x try check selected two activities b clash x instead b course clash otherwise final result improve now back previous case x two clashes b one case b selected beginning way disprove assumption make b clash affecting activities except x intuitive think unfortunately build case activities represented blue lines optimal choice given schedule activity red produces 2 clashes chosen first 4 compatible activities left clash select one happens activities scheduled leaving space one choice gives 3 activities optimum choice selects 4 every solution came hidden flaw seems deal devilish problem actually problem quite elegant straightforward solution study figure carefully see blue activity bottom left one finishes timeline indicated thin vertical bar choose single activity choosing one ends first time t1 leave remaining time interval free choosing activities choose activity instead remaining time interval shorter obvious end anyway one activity chosen time t2 t1 first case available time span t1 finish included time t2 finish consequently disadvantage choosing activity finishes earlier advantage result situation able insert another activity starts t1 t2 ends end activity starts time t2 known activity selection standard problem solved greedy method greedy man takes much often case choosing every step activity finishes first every time activity progress truth make greedy decisions point life go shopping drive car make choices seem best moment actually two basic ingredients every greedy algorithm common greedy choice property local optimum reach global optimum reconsider decisions already taken optimal substructure property optimal solution problem determined optimal solutions subproblems following pseudo code describes optimal activity selection given greedy algorithm proven earlier let n denote number activities activity 1 n consider s f starting finishing time sort activities increasing order finishing time every j f f j denotes set activities selected 1 j denotes last activity selected j 1 2 n select activity last activity selected already finished s f j select activity activity now becomes last activity selected j endif endfor return applying algorithm johnny s fun plan look like eliminate bugs take time rest tuesday chess prepare beat whole day starcraft follows fun next two days recovery final day get rating points topcoder take shower enjoy versatile food good quality wine problem john smith solved just one example greedy examples real topcoder problems help understand concept better moving wish practice little bit read problem similar activity selection named boxing bioscore problem asked maximize average homology score pairs set optimal solution required valuable clue determining appropriate method use usually kind problems solved dynamic programming many cases greedy strategy also employed first thing build frequency matrix easy task just compare every pair two sequences count occurrences combinations nucleic acids aa ac ag ca cc cg ct ga gc gg gt ta tc tg tt combinations element matrix value represent total number occurrences example let s take set actagagac aaaaaaaaa tagtcatac gcagcattc used example 2 bottom right part figure see resulting frequency matrix let denote f now find another matrix s sum 16 corresponding products type f j s j 1 j 4 maximized now let s look matrix restrictions analyze one one 1 sum 16 entries 0 like commonsense condition elements f positive final score tends increase increase elements s sum kept 0 order increase element ll decrease others challenge problem resides finding optimal distribution 2 entries integers 10 10 inclusive another commonsense condition search space drastically reduced still left lot alternatives 3 symmetric score x y score y x symmetry attribute homology score combinations like ac ca result also count occurrences together previous example set combinations following frequencies intuitive approach assign higher homology score combinations appear often keep score sum 0 another problem arises combinations like aa cc gg tt appear matrix homology score contribute less total sum 4 diagonal entries positive score x x 0 restriction differentiates elements diagonal others even basically two groups four elements diagonal correspond combinations aa cc gg tt six elements diagonal correspond combinations ac ca ag ga ta cg gc ct tc gt tg groups different states depending value assign elements make things easier possible state first group wish find optimal state second group elements second group property try find optimal state using greedy approach elements first group take values 1 10 sum wish obtain scores choose second group recalculated s easy notice sum elements first group range anywhere 4 40 result depending choice make first group ll obtain sum 2 20 second forget symmetrical elements matrix coupled together thus count twice score matrix now finally reached problem core solution entire problem depends finding optimal choice scores second group problem indeed greedy choice property optimal substructure property ll able pick one element form group assign best scenario proceed remaining elements manner claim always give highest possible score combination occurrences group ll obtain end highest possible score entire group first thing sort six elements matrix f actually compute corresponding score values s total score obtain least 20 one quick insight tells first two elements given score 10 assign 10 remaining four elements 20 still achieved know well final score less 0 want maximize scores first elements last three elements 10 best case score sum elements 2 assign scores following manner 10 10 8 10 10 10 finally value third element depend choices make first group maximum 10 subtract half score sum elements first group note aforementioned sum even now make sure approach indeed correct proof quite straightforward order keep sum s constant decrease score combination occurrences increase score combination fewer occurrences let f1 f2 frequencies two combinations f1 f2 f1 s1 f2 s2 x x sum maximize greedy assumption s1 s2 s1 s2 remains constant previous sum changes f1 s1 f2 s2 y strictly greater 0 find y x f2 f1 f1 f2 difference always less equal 0 results y x y chosen arbitrarily concluded initial greedy choice always gives maximum possible score apply algorithm described state elements first group save best result representation instead using matrices f s find convenient use arrays storing combination frequencies corresponding score first 4 elements f denote frequency combinations aa cc gg tt next 6 elements denote possible combinations sorted decreasing order frequency f 5 f 6 f 7 f 8 f 9 f 10 s array 10 elements s score attribute combination main algorithm illustrated following pseudo code given score matrix case array s compute final result just making sum products form f s 1 10 divide n n 1 2 order obtain average homology score goldmine now going see gold exploited fullest greedy whenever notice maximum profit involved greedy switch activate case allocate miners available mines total profit maximized short analysis realize want know much money earned possible cases many cases 0 6 workers table represents possible earnings two mines described example 0 problem statement going assign workers different mines interested profit certain worker bring assigned easily determined compute difference earnings resulted worker one worker optimal choice allocate bring best profit workers want check assigning manner bring best global profit example 4 workers assigned table shows profit obtained two mines additional worker end two workers allocated first another two second example shows indeed choice best total profit greedy approach always work claim obtain maximum total profit assign workers one one bring best immediate profit proof let b two mines a1 a2 b1 b2 defined a1 profit obtained additional worker assigned a1 a2 profit obtained two additional workers assigned b1 profit obtained additional worker assigned b b1 b2 profit obtained two additional workers assigned b let now consider two workers assign a1 b1 greedy algorithm increase profit a1 first worker max a2 b1 second worker total profit case a1 max a2 b1 choose profit b1 first worker instead alternatives second worker profit a1 profit b2 first case total profit b1 a1 a1 max a2 b1 second case total profit b1 b2 need prove b1 b2 a1 max a2 b1 b2 b1 profit allocating extra worker always higher equal profit allocating next extra worker b1 b2 a1 b2 a1 b1 a1 max a2 b1 greedy choice indeed best coding difficult one take account problem constraints miners placed six workers worker optimally assigned one put lowest index worldpeace greedy algorithms seen work well every possible situation correction proven another class optimization problems greedy algorithms found applicability category mostly includes np complete problems like traveling salesman problem one prefer write heuristic based greedy algorithm wait solution always best real purposes good enough problem np excellent example simple greedy algorithm adapted fool examples also carefully designed system tests algorithm hard come short analysis notice order maximize total number groups always optimal form group k countries highest number citizens apply principle every single step sort sequence see next k countries highest number citizens idea illustrated following pseudo code execution time longer problem algorithm check example 0 method returns 4 instead 5 result returned examples 1 2 3 correct last example instead making 3983180234 groups able make 3983180207 taking account small difference say solution pretty good maybe refine direction two algorithms first greedy algorithm accurate fast enough second greedy algorithm fast accurate want optimize accuracy much exceeding execution time limit basically looking truce speed accuracy difference two algorithms described number groups select given time compromise make select arbitrarily large number groups beginning approach end start cautious left just ungrouped citizens every country makes complete sense use safe brute force approach variable allowance defined algorithm control number groups want make given moment approach correct indeed remains seen despite fact escaped tomek s keen eyes system tests likely result optimal set possible test cases just example show carefully chosen refinement simple obvious faulty greedy approach actually right way accurate solutions problem see match editorial conclusion greedy algorithms usually easy think easy implement run fast proving correctness require rigorous mathematical proofs sometimes insidious hard addition greedy algorithms infamous tricky missing even small detail fatal nothing else disposal salvation backtracking dynamic programming relatively safe ground greedy instead like walking mined field everything looks fine surface hidden part backfire least expect standardized problems problems solvable method call heuristics general template apply greedy method given problem however problem specification give good insight advanced mathematical concepts matroids give recipe proving class problems solved greedy ultimately comes keen sense experience programmer cases lot greedy assumptions one make correct see activity selection problem cases hard problem hide ingenious greedy shortcut like case last problem discussed worldpeace actually whole beauty greedy algorithms needless say provide excellent challenge opportunities final notes problem seems extremely complicated surface see tcsocks signal greedy approach problems large input size n 2 algorithm fast enough also likely solved greedy backtracking dynamic programming despite rigor look greedy approaches eyes detective glasses mathematician